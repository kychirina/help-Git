ШПАРГАЛКА ПО КОМАНДАМ GIT
________________________________________________________________________________________________________________
ПРОВЕРИТЬ ТЕКУЩИЕ НАСТРОЙКИ (сами настройки записываются в файл C:/user/username/.gitconfig): git config --list

!!!Если вы планируете клонировать его по ssh с удаленной машины, укажите: git config --bool core.bare true

… иначе при git push вы будете получать странные ошибки вроде:
Refusing to update checked out branch: refs/heads/master
By default, updating the current branch in a non-bare repository
is denied, because it will make the index and work tree inconsistent
with what you pushed, and will require 'git reset --hard' to match
the work tree to HEAD.
_________________________________________________________________________________________________________________
ДОБАВЛЕНИЕ ИЗ ЛОКАЛЬНОГО В УДАЛЕННЫЙ РЕПОЗИТОРИЙ:
1. Зайти в директорию компьютера, где лежит файл, который надо дабавить: cd имя_диска:/имя_папки
2. Создать репозиторий: git init 
3. Добавить коментарий: git commit -m "имя коммита"
4. Проверка текущего статуса репозитория: git status
    - если есть изменения добавляем их: git add . (где "." - это все изменения)
    - добавление коментария: git commit -m "имя коммита"
5. Зайти на свой профиль в github, добавить новый репозиторий, указав его имя и коментарий
6. Скопиравать команды сгенерированные в github: 
    - указать директорию репозитория: git remote add origin https://github.com/имя_профиля/имя_репозитория.git
    - запушить файл, который надо дабавить на репозиторий: git push -u origin master
_________________________________________________________________________________________________________________
НАЧАЛО РАБОТЫ:
1. Создать файл с пояснениями к новому проекту: README.md  
2. Создать файл с теми файлами и папками которые не должны появится: .gitignore
3. Создать новый репозиторий: git init project-name
4. Создать первый коментарий (с помощью панели Git): git commit -m "имя коммита"
                             (с помощью $EDITOR): git commit -a
5. Указать адрес удаленного репозитория: git remote add origin https://github.com/YouName/имя репозитория
6. Создание главной удаленной ветки: git push -u origin master 
7. Замерджить ветку с удаленного репозитория:
    - все ветки: git pull origin
    - только ветка master: git pull origin master
    - только текущая ветка, не вводя ее длинное имя: git pull origin HEAD
8. После работы с проектом (внесения изменений, неразрешенные конфликты и тп):
    - проверка текущего статуса репозитория: git status
    - добавление в репозиторий:  git add . (где "." - это все изменения)
    - добавление коментария: git commit -m "имя коммита"
9. Отмена внесенных изменений:
    - до конкретного коммита: git reset --hard d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4 (хэш смотрим в «git log»)
    - аналогично предыдущему, но файлы на диске остаются без изменений: git reset --soft d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4
    - обратить заданный commit (но чаще используется branch/reset + merge): git revert d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4
    - изменить коммит (добавить забытый файл): git commit --amend
    - отмена индексации файла: git reset HEAD имя файла
    - отмена изменений файла: git checkout -- имя файла
    - просмотр изменений (суммарных, а не всех по очереди, как в «git log»): git diff # (подробности см в "git diff --help")
10. Ветвление (бранч):
    - создать новую  ветку: git branch имя ветки
    - переключиться на другую ветку (из тех, с которыми уже работаем): git checkout имя ветки
    - создание и одновременно переключение на другую ветку: git checkout -b имя ветки
    - сравнение веток: git diff имя ветки1..имя ветки2
    - переименование ветки: git branch -m старое_имя_ветки новое_имя_ветки
    - получаем список веток, с которыми работаем: git branch # звездочкой отмечена текущая ветвь
    - просмотреть все существующие ветви: git branch -a # | grep something
    - слияние веток (забрать нужные изменения):
        а) переключиться на ветку в которую будут приняты изменения: git checkout имя_ветки_в_которую_будут_приняты_изменения 
        б) замерджить изменения из текущей ветки: git merge имя_ветки_с_нужными_изменениями 
    - удалить бранч (после мерджа): git branch -d имя_ветки
    - просто удалить бранч (тупиковая ветвь): git branch -D имя_ветки
11. Запушить ветку на удаленный репозиторий:
    - все ветки локального репозитория: git push origin
    - только ветки master: git push origin master
    - текущую ветку, не вводя целиком ее название: git push origin HEAD
    - если хотим пушить один код в несколько репозиториев: git remote add remotename git@gitlab.example.ru:repo.git


КЛОНИРОВАТЬ РЕПОЗИТОРИЙ С УДАЛЕННОЙ МАШИНЫ:
git clone git@bitbucket.org:afiskon/hs-textgen.git

ДОБАВИТЬ ФАЙЛ В РЕПОЗИТОРИЙ:
git add text.txt

УДАЛИТЬ ФАЙЛ:
git rm text.txt

Скачать все ветки с origin, но не мерджить их в локальный репозиторий:
git fetch origin

Аналогично предыдущему, но только для одной заданной ветки:
git fetch origin master

Начать работать с веткой some_branch (уже существующей):
git checkout -b some_branch origin/some_branch

История изменений:
git log

История изменений в обратном порядке:
git log --reverse

История конкретного файла:
git log file.txt

Аналогично предыдущему, но с просмотром сделанных изменений:
git log -p file.txt

История с именами файлов и псевдографическим изображением бранчей:
git log --stat --graph

Изменения, сделанные в заданном коммите:
git show d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4

Посмотреть, кем в последний раз правилась каждая строка файла:
git blame file.txt

Удалить бранч из репозитория на сервере:
git push origin :branch-name

Используем vimdiff в качестве программы для разрешения конфликтов (mergetool) по умолчанию:
git config --global merge.tool vimdiff

Отключаем диалог «какой mergetool вы хотели бы использовать»:
git config --global mergetool.prompt false

Отображаем табы как 4 пробела, например, в «git diff»:
git config --global core.pager 'less -x4'

Создание глобального файла .gitignore:
git config --global core.excludesfile ~/.gitignore_global

Разрешение конфликтов (когда оные возникают в результате мерджа):
git mergetool

Создание тэга:
git tag some_tag # за тэгом можно указать хэш коммита

Удаление untracked files:
git clean -f

«Упаковка» репозитория для увеличения скорости работы с ним:
git gc

Иногда требуется создать копию репозитория или перенести его с одной машины на другую. Это делается примерно так:
mkdir -p /tmp/git-copy
cd /tmp/git-copy
git clone --bare git@example.com:afiskon/cpp-opengl-tutorial1.git
cd cpp-opengl-tutorial1.git
git push --mirror git@example.com:afiskon/cpp-opengl-tutorial2.git

Следует отметить, что Git позволяет использовать короткую запись хэшей. Вместо «d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4» можно писать «d8578edf» или даже «d857».

Дополнение: Также в 6-м пункте Мини-заметок номер 9 приводится пример объединения коммитов с помощью git rebase, а в 10-м пункте Мини-заметок номер 11 вы найдете пример объединения двух репозиториев в один без потери истории.
Работа с сабмодулями

Более подробно сабмодули и зачем они нужны объясняется в заметке Простой кроссплатформенный OpenGL-проект на C++. Здесь упомянем самое главное.

Добавить сабмодуль:
git submodule add https://github.com/glfw/glfw glfw

Инициализация сабмодулей:
git submodule init

Обновление сабмодулей, например, если после git pull поменялся коммит, на который смотрит сабмодуль:
git submodule update

Удаление сабмодуля производится так:

    Скажите git rm --cached имя_сабмодуля;
    Удалите соответствующие строчки из файла .gitmodules;
    Также грохните соответствующую секцию в .git/config;
    Сделайте коммит;
    Удалите файлы сабмодуля;
    Удалите каталог .git/modules/имя_сабмодуля;

Дополнительные материалы

В качестве источников дополнительной информации:

    Why Git is Better than X;
    Хабростатья «Почему Git?»;
    Книга «Pro Git» на русском языке;
    Книга «Волшебство Git» на русском языке;
